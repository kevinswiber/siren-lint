#! /usr/bin/env node

// vim: set filetype=javascript shiftwidth=2 tabstop=2 expandtab:

var fs = require('fs');
var validate = require('../validate');

if (process.stdin.isTTY) {
  if (process.argv.length < 3) {
    console.log('Usage: sirenlint <filename>');
  } else {
    var content = fs.readFileSync(process.argv[2], { encoding: 'utf8' });
    validateContent(content);
  }
} else {
  var content = '';

  process.stdin.setEncoding('utf8');
  process.stdin.on('readable', function() {
    var chunk = this.read();
    if (chunk != null) {
      content += chunk;
    }
  });

  process.stdin.on('end', function() {
    validateContent(content);
  });
}

function validateContent(content) {
  var pruned = extractHttpResponseBody(content);
  var results = validate(pruned);

  console.log(content);
  console.error('');

  if (results.length === 0) {
    console.error('sirenlint: no problems found');
  } else {
    var problems = results.length == 1
      ? '1 problem was found'
      : results.length + ' problems were found';

    console.error('sirenlint: ' + problems + '\n');
  }

  results.forEach(function(r) {
    if (r instanceof validate.ValidationWarning) {
      console.error('warning:', JSON.stringify(r.segments) + ',', r.message);
    } else if (r instanceof validate.ValidationError) {
      console.error('error:', JSON.stringify(r.segments) + ',', r.message);
    }
  });
};

// extractHttpResponseBody removes the status line and headers.
// It also handles HTTP/1.1 100 Continue responses, which
// include two sets of response lines and headers.
function extractHttpResponseBody(content) {
  if (content.length < 5 || content.slice(0, 5) !== 'HTTP/') {
    return content;
  }

  var emptyLineChars = '\r\n\r\n';

  var index = content.indexOf(emptyLineChars);
  if (index !== -1) {
    var hasContinueLine = (content.length > 21
        && content.slice(9, 21).toLowerCase() === '100 continue');

    content = content.slice(index + emptyLineChars.length);

    if (hasContinueLine) {
      return extractHttpResponseBody(content);
    }
  }

  return content;
}
